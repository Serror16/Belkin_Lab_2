System_Shell - консольная программа, которая имитирует поведение командной строки. Причем System_shell кросплатформенна и работает как на Windows, так и на Linux.

Краткий принцип работы программы:
    1. При запуске main.py, функция run() запускает бесконечный цикл while True, который прерывается только при вводе пользователем команды exit().
    2. Программа считывает введенные пользователем команды и парсит их. Далее в зависимости от введенной команды, программа вызывает соответствующую функцию(ls, cd, cp, rm, mv и тд.)
    3. Вызванная функция сама создает нужные для выполнения команды пути и зависимости. В большинстве функций основные действия(копирование, удаление, премещение и тд.) выполняются при помощи данных библиотек и их методов:
        os: os.listdir(); os.stat(); os.path.join(); os.chdir(); os.remove();  os.path.abspath(); os.makedirs();

        shutil: shutil.copytree(); shutil.copy2(); shutil.rmtree(); shutil.move();
    4. После завершения выполнения команды(или если было вызвано исключение) результат выполнения команды добавляется в список обработанных команд(self.history = []) при помощи функции add_to_history(), а также записывается в файл .history, при помощи функции save_history().
    5. После выполнения выше изложенного алгоритма, программа снова ожидает ввода команд от пользователя.
    *6. Также у программы есть файл с тестами - tests.py, в котором реализованы базоввые тесты каждой из функций, а также обработка исключений(FileNotFoundError, PermissionError, IsADirectoryError).

На этом основная часть описания программы для рядового пользователя окончена. Далле будет придставлено подробное описание работы каждой из функций, для прекрасного и многоуважаемого Untronix0nly.

Итак, первая функция, которая требует подробного рассмотрения это check_history:
    Данная функция нужна для того чтобы каждый новый запуск программы, имел доступ к истории команд, обработанных предыдущими запусками.

    Принцип работы:
        1. Функция считывает данные об обработанных командах из файла .history, и добавляет их в список history, чтобы данный запуск программы мог оперировать данными из прошлых запусков.

    Исключения:
        1. OSError:
            Вывод:
                1. При появлении исключения, выводит пользователю текст ошибки: File with history didn't find.

save_history:
    Данная функция выполняет обратное к предыдущей действие - перезаписывает в файл .history последние 10 команд. Число 10 выбрано только лишь потому что это учебный проект, и на данном этапе 10 последних команд в файле .history вполне достаточно для корректной работы с программой.

    Принцип работы:
        1. Функция берет последние 10 команд из списка, и перезаписывает файл .history добавляя только последние 10 команд. При таком подходе, файл .history всегда остается фиксированного объема(в нем всегда <= 10 команд), однако есть и минусы - в файле .history всегда храниться только последние 10 команд, а более ранние безвозвратно удаляются. Это можно балансировать при помощи изменения количества записываемых команд(например с 10 до 50).

    Исключения:
        1. OSError:
            Вывод:
                1. При появлении исключения, выводит пользователю текст ошибка: Could't save command history.

add_to_history():
    Данная функция добавляет команду и информацию о ней(ее аргументы и атрибуты) в список команд. А также вызывает функцию save_history, которая в свою очередь добавляет эту команду в файл .history. Таким образом данная функция является ключевой, и выполняет весь путь по записи команды в историю, после ее выполнения программой.

    Принцип работы:
        1. Функция создает словарь, в который добавляет полученные ей данные о команде:
            'time': время выполнения команды,
            'command': имя команды,
            'args': аргументы(пути, флаги и тд.),
            'status': статус выполнения(success/error),
            'current_dir': текущую директорию,
            'other_data': дополнительную информацию.
        2. Далее функция добавляет созданный словарь в список команд.
        3. После этого функция вызывает save_history, которая в свою очередь записывает эту команду в файл .history.

ls():
    Данная функция соответствует команде ls() в консоли. Функция выводит пользователю список содержимого в указанной директории(по умолчанию в текущей директории). Также функция поддерживает флаг -l, который указывает функции, что нужно вывести подробную информацию об объектах в указанной дирректории.

    Принцип работы:
        1. Считывает директорию, о которой следует вывести инфу(по умолчанию текущая директория).
        2.Далее с помощью os.listdir(), получает список элементов в директории.
        3.
        Если нет флага -l:
            Объединяет элементы списка в строку, добавляя разделителями \n. И выводит эту строку пользователю.
        Если есть флаг -l:
           3.1. Проходит по каждому элементу списка, и с помощью os.path.join() составляет путь до него.
           3.2. Далее при помощи os.stat() получает информацию об элементе.
           3.3. Выводит пользователю строку с подробной информацией об элементе(размер, время последнего изменения, права доступа в цифровом виде).
        4. Далее вызывает функцию add_log(), которая добавляет информацию о выполненной команде в лог-файл.
        5. Вызывает функцию add_to_history(), которая записывает команду в историю.

    Исключения:
        1. OSError:
            Вывод:
                1. При появлении исключения, выводит пользователю текст исключения.
            Также как в пунктах 4-5 добавляет инфу об исключении в лог-файл и историю.

cd():
    Данная функция соответствует команде cd() в консоли. Функция выполняет смену текущей директории.

    Принцип работы:
        1. Считывает директорию в которую нужно перейти:
            1.1. Если введен "..":
                При помощи функции os.path.dirname() создает путь к предыдущей директории(от пути текущей директории отбрасывает ее имя).
            1.2. Если введен "~":
                Создает путь к корневой директории, при момощи функции os.path.expanduser(). Данная функция преобразует символ "~", в путь к домашней директории.
            1.3. Если введено название директории:
                Создает полный(абсолютный) путь к данной директории при помощи функции os.path.abspath().
        2. Далее при помощи функции os.chdir(), программа выполняет переход к новой директории.
        3. Также при переходе изменяется константа, хранящая имя текущей директории.
        4. Далее вызывает функцию add_log(), которая добавляет информацию о выполненной команде в лог-файл.
        5. Вызывает функцию add_to_history(), которая записывает команду в историю.

    Исключения:
        1. FileNotFoundError:
            Вывод:
                1. При появлении исключения, выводит пользователю текст ошибки: Directory '...' doesn't exist.
        2. OSError:
            Вывод:
                1. При появлении исключения, выводит пользователю текст исключения.
            Также как в пунктах 4-5 добавляет инфу об исключении в лог-файл и историю.

cat():
    Данная функция соответствует команде cat() в консоли. Функция выводит содержимое указанного файла.

    Принцип работы:
        1. При помощи os.path.join() создает путь к указанному файлу.
        2. Далее функция чиатет указанный файл, и выводит его содержимое пользователю.
        3. Далее вызывает функцию add_log(), которая добавляет информацию о выполненной команде в лог-файл.
        4. Вызывает функцию add_to_history(), которая записывает команду в историю.

    Исключения:
        1. IsADirectoryError:
            Вывод:
                1. При появлении исключения, выводит пользователю текст ошибки: "..." is a directory.
        2. OSError:
            Вывод:
                1. При появлении исключения, выводит пользователю текст исключения.
            Также как в пунктах 3-4 добавляет инфу об исключении в лог-файл и историю.

cp():
    Данная функция соответствует команде cp() в консоли. Функция копирует указанные файлы и директории. Также функция поддерживает флаг -r, который применим только при копировании директорий и указывает функции, что следует рекурсивно скопировать указанную директорию.

    Принцип работы:
        1. При помощи os.path.join() создает пути к указанным файлам.
        2. Проверяет, свляется ли объект "куда копировать" директорией:
            Если является, то создает в этой директории файл с именем копируемого, при помощи basename(). Точнее он создает путь к этому файлу.
        3. Проверяет, является ли копируемый объект директорией и наличие флага -r:
            3.1 Если объект - директория, и есть флаг -r, то происходит рекурсивное копирование, при помощи shutil.copytree().
            3.2. Если объект - не директория, то происходит копирование его как файла, при помощи shutil.copy2().
            3.3 Если объект - директория, но нет флага -r, то вызывается исключение IsADirectoryError.
        4. Далее вызывает функцию add_log(), которая добавляет информацию о выполненной команде в лог-файл.
        5. Вызывает функцию add_to_history(), которая записывает команду в историю.

    Исключения:
        1. IsADirectoryError:
            Вывод:
                1. При появлении исключения, выводит пользователю текст ошибки: "..." is a directory.
        2. OSError:
            Вывод:
                1. При появлении исключения, выводит пользователю текст исключения.
            Также как в пунктах 4-5 добавляет инфу об исключении в лог-файл и историю.

mv():
    Данная функция соответствует команде mv() в консоли. Функция перемещает или переименовывает файлы.

    Принцип работы:
        1. При помощи os.path.join() создает пути к указанным файлам.
        2. Проверяет, является ли объект "куда перемещать" директорией:
            Если является, то создает в этой директории файл с именем перемещаеимого, при помощи basename(). Точнее он создает путь к этому файлу.
        3. Далее при помощи shutil.move() происходит перемещение объекта в нужное место.
        4. Далее вызывает функцию add_log(), которая добавляет информацию о выполненной команде в лог-файл.
        5. Вызывает функцию add_to_history(), которая записывает команду в историю.

    Исключения:
        1. FileNotFoundError:
            Вывод:
                1. При появлении исключения, выводит пользователю текст ошибки: File "..." doesn't exist.
        2. OSError:
            Вывод:
                1. При появлении исключения, выводит пользователю текст исключения.
            Также как в пунктах 4-5 добавляет инфу об исключении в лог-файл и историю.

rm():
    Данная функция соответствует команде mv() в консоли. Функция удаляет указанный файл или директорию. Также функция поддерживает флаг -r, который применим только при удаления директорий и указывает функции, что следует рекурсивно удалить указанную директорию.

    Принцип работы:
        1. При помощи os.path.join() создается путь к удаляемому объекту.
        2. Далее происходит проверка не передан ли в касестве удаляемого файла фргумент "/" или ".." или не передан ли путь к корневому каталогу:
            Если передан один из этих аргументов, то вызывается исключение.
        3. Далее, при помощи os.makedirs() происходит создание(в случае, если ее нет) директория .trash.
        4. Далее функция создает уникальное имя для файла, чтобы в поместить его в директорию .trash.
        Формирование уникального имени:
            4.1. При помощи datetime.now().strftime() записываем в переменную time дату и время удаления объекта в формате(год:месяц:день_часы:минуты:секунды)
            4.2. При помощи basename() записывает в перененную base_name имя удаляемого файла.
            4.3. При помощи os.path.join() создает путь к удаляемому файлу в директории .trash, с именем({base_name}_{time}).
        5. Далее при помощи os.path.relpath() создает путь от текущей директории к удаляемому файлу.
        6. Проверяет на наличие пути из пункта 5(проверяет не находится ли удаляемый файл в текущей директории):
            6.1. Если такой путь есть, то создаем аналогичный путь, только уже внутри директории .trash.
            6.2. Далее, если такого каталога внутли .trash еще нет, то при помощи os.makedirs() он создается и после создания изменяем путь к файлу в директории .trash(был путь .trash/file, а стал .trash/dirs/file).
        7. Далее идет проверка флага -r и проверка на директорию:
            7.1. Если есть флаг -r, и объект является директорией, то запрашиваем у пользователя подтверждение действия. Далее в зависимости от ответа производим либо удаление с помощью shutil.move(), либо отменяем команду и выводим сообщение: Operation cancelled.
            7.2. Если же отсутствует флаг -r, но объект является директорией, то вызывается исключение IsADirectoryError.
            7.3. Однако если объект не является директорией, то программа пытается при помощи shutil.copy2() и os.remove() скопировать файл в .trash. Однако если вызывается исключение, то программа делает вторую потытку переместить файл, при помощи shutil.move().
            #Это наверное "костыль", но мне пришлось сделать именно так, так как в некоторых случаях первый способ вызывал исключение.
        8. Далее вызывает функцию add_log(), которая добавляет информацию о выполненной команде в лог-файл.
        9. Вызывает функцию add_to_history(), которая записывает команду в историю.

    Исключения:
        1. IsADirectoryError:
            Вывод:
                1. При появлении исключения, выводит пользователю текст ошибки: "..." is a directory.
        2. FileNotFoundError:
            Вывод:
                1. При появлении исключения, выводит пользователю текст ошибки: File "..." doesn't exist.
        3. PermissionError:
            Вывод:
                1. При появлении исключения, выводит пользователю текст ошибки: Can't delete root directory.
        4. OSError:
            Вывод:
                1. При появлении исключения, выводит пользователю текст исключения.
            Также как в пунктах 8-9 добавляет инфу об исключении в лог-файл и историю.

show_history():
    Данная функция выводит историю пользователю.

    Принцып работы:
        1. Проверка существования списка команд. Если он отсутствует, выводит пользователю сообщение: No command in history.
        2. Вычисление стартового индекса:
            2.1. Если команд в списке больше чем пользователь просит вывести, то стартовый индекс равен: кол-во команд в списке - число, переданное пользователем.
            2.2. Если команд в списке меньше чем просит пользователь, то стартовый индекс равен 0.
        3. Проходит по каждой команде в списке, начиная со стартового индекса:
            3.1. Считывает статус выполнения команды.
            3.2. Считывает время выполнения команды.
            3.3. Считывает список аргументов команды.
            3.4. Выводит команду пользователю в формате: "{i} {status} [{time}] {info['command']} {str_args}".
        4. Далее вызывает функцию add_log(), которая добавляет информацию о выполненной команде в лог-файл.
        5. Вызывает функцию add_to_history(), которая записывает команду в историю.

    Исключения:
        1. OSError:
            Вывод:
                1. При появлении исключения, выводит пользователю текст исключения.

undo():
    Данная функция отменяет результат выполнения последней команды(команда должна иметь статус = "success"). Поддерживает отмену команд: cp, rm, mv.

    Принцип работы:
        1. Проверка существования списка команд. Если он отсутствует, выводит пользователю сообщение: No command to cancel.
        2. Проходит по списку команд в обратном порядке(от новых к старым).
            2.1. Если команда является одной из этих: (cp, rm, mv), и статус команды равен "success", то команда сохраняется как последняя команда, которую можно отменить.
        3. Если команды, которые возможно отменить отсутствуют, то пользователю выводится сообщение:  No commands to cansel.
        4. Далее алгоритм разнится в зависимости от отменяемой команды:
            cp:
                1. Из дополнительной информации об операции берем путь к месту куда был скопирован объект.
                2. Проверка на существование места и скопированного объекта.
                3. Далее если объект - файл, при помощи os.remove() он удаляется. Если же объект - директория, то при помощи shutil.rmtree() она удаляется.
            mv:
                1. Из дополнительной информации об операции берем путь к месту где изначально находился объект и путь к месту куда был перемещен объект.
                2. Проверка на существование мест, и перемещенного объекта.
                3. Далее при помощи shuti.move(), объект перемещается на изначальное место.
            rm:
                1. Из дополнительной информации об операции берем путь к месту куда был перемещен объект в директории .trash, а также берем путь к его местоположению до удаления.
                2. Проверка на существование мест, и перемещенного в .trash объекта.
                3. Результаты проверки:
                    3.1. Если проверка пройдена, то при помощи shutil.move(), перемещает объект на прежнее место.
                    3.2. Если проверка не пройдена, выводит пользователю сообщение об ошибке: Couldn't cancel operation.
        5. Удаляет отмененную команду из списка при помощи remove().
        6. Далее вызывает функцию save_history(), которая перезаписывает историю удаляя отмененную команду, и добавляя команду undo.
        7. Далее вызывает функцию add_log(), которая добавляет информацию о выполненной команде в лог-файл.
        8. Вызывает функцию add_to_history(), которая записывает команду в историю.

    Исключения:
        1. OSError:
            Вывод:
                1. При появлении исключения, выводит пользователю текст исключения.

Ну и наконец-то долгожданная функция run():
    Данная функция запускает основной цикл выполнения программы. Также функция обрабатывает пользовательский ввод, парсит команды и в соответствии с результатами парсинга вызывает соответствующие функции.

    Принцип работы:
        1. Запускает цикл while True, который останавливается только после введения пользователем команды exit.
        2. С помощью функции input() программа считывает введенные пользователем команды.
        3. Далее эти команды парсятся(делятся на название, и список аргументов и атрибутов).
        4. Далее система вызывает соответствующую введенной пользователем команде функцию. В качестве аргументов для вызываемых функций программа берет значения из списка аргументов, также анализируя наличие флагов.
        5. Если аргументов не хватает, то программа выводит пользователю ошибку: not enouth arguments.

    Исключения:
        1. KeyboardInterrupt:
            1. При появлении исключения, выводит пользователю текст ошибки: Use 'exit' to quit.
        2. Exception:
            1. При появлении исключения, выводит пользователю текст ошибки: Unexpected error: "текст ошибки".

Итак, здесь я постарался подробно описать работу каждой функции программы, а также затронул несколько ньюансов и сложностей при разработке System_shell.

Спасибо за внимание к моей лабораторной работе!
